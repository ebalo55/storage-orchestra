// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file
// manually.

/** user-defined commands **/


export const commands = {
    async startServer(): Promise<Result<number, string>> {
        try {
            return {status: "ok", data: await TAURI_INVOKE("start_server")};
        }
        catch (e) {
            if (e instanceof Error) {
                throw e;
            }
            else {
                return {status: "error", error: e as any};
            }
        }
    },
    /**
     * Sets the password for the application secure storage.
     *
     * # Arguments
     *
     * * `password` - The password to set.
     *
     * # Returns
     *
     * Nothing.
     */
    async initState(password: string): Promise<Result<null, string>> {
        try {
            return {status: "ok", data: await TAURI_INVOKE("init_state", {password})};
        }
        catch (e) {
            if (e instanceof Error) {
                throw e;
            }
            else {
                return {status: "error", error: e as any};
            }
        }
    },
    /**
     * Gets data from the state.
     *
     * # Arguments
     *
     * * `state` - The state to get the data from.
     * * `key` - The key to get the data from.
     *
     * # Returns
     *
     * The data as a JSON value.
     */
    async getFromState(key: AppStateInnerKeys): Promise<Result<AppStateInnerResult, string>> {
        try {
            return {status: "ok", data: await TAURI_INVOKE("get_from_state", {key})};
        }
        catch (e) {
            if (e instanceof Error) {
                throw e;
            }
            else {
                return {status: "error", error: e as any};
            }
        }
    },
    /**
     * Removes data from the state.
     *
     * # Arguments
     *
     * * `state` - The state to remove the data from.
     * * `key` - The key to remove the data from.
     *
     * # Returns
     *
     * Nothing.
     */
    async removeFromState(key: AppStateInnerKeys): Promise<Result<null, string>> {
        try {
            return {status: "ok", data: await TAURI_INVOKE("remove_from_state", {key})};
        }
        catch (e) {
            if (e instanceof Error) {
                throw e;
            }
            else {
                return {status: "error", error: e as any};
            }
        }
    },
    /**
     * Inserts data in the state.
     *
     * # Arguments
     *
     * * `state` - The state to insert the data in.
     * * `value` - The data to insert.
     *
     * # Returns
     *
     * Nothing.
     */
    async insertInState(value: AppStateInnerResult): Promise<Result<null, string>> {
        try {
            return {status: "ok", data: await TAURI_INVOKE("insert_in_state", {value})};
        }
        catch (e) {
            if (e instanceof Error) {
                throw e;
            }
            else {
                return {status: "error", error: e as any};
            }
        }
    },
    /**
     * Checks if the user is authenticated.
     *
     * # Returns
     *
     * True if the user is authenticated, false otherwise.
     */
    async isAuthenticated(): Promise<boolean> {
        return await TAURI_INVOKE("is_authenticated");
    },
    /**
     * Gets the password for the application secure storage if already loaded in memory.
     *
     * # Why
     *
     * This function is useful when the frontend needs to initialize the State class or some other
     * singleton but the password was not provided at application startup.
     * This is most commonly a development issue (commonly derived from hot-reloading) but implementing
     * a safe reboot of singleton in case the password is missing can be useful to improve the user
     * experience.
     *
     * **Note**: This function DOES NOT expose the password to other applications or the networks.
     *
     * # Returns
     *
     * The password.
     */
    async getPassword(): Promise<Result<string, string>> {
        try {
            return {status: "ok", data: await TAURI_INVOKE("get_password")};
        }
        catch (e) {
            if (e instanceof Error) {
                throw e;
            }
            else {
                return {status: "error", error: e as any};
            }
        }
    },
    /**
     * Gets the settings of the application.
     *
     * # Arguments
     *
     * * `state` - The state to get the settings from.
     *
     * # Returns
     *
     * The settings of the application.
     */
    async loadSettings(): Promise<Result<Settings, string>> {
        try {
            return {status: "ok", data: await TAURI_INVOKE("load_settings")};
        }
        catch (e) {
            if (e instanceof Error) {
                throw e;
            }
            else {
                return {status: "error", error: e as any};
            }
        }
    },
    /**
     * Updates the settings of the application.
     *
     * # Arguments
     *
     * * `state` - The state to update the settings in.
     * * `value` - The settings to update.
     *
     * # Returns
     *
     * Nothing.
     */
    async updateSettings(value: SettingsResult): Promise<Result<null, string>> {
        try {
            return {status: "ok", data: await TAURI_INVOKE("update_settings", {value})};
        }
        catch (e) {
            if (e instanceof Error) {
                throw e;
            }
            else {
                return {status: "error", error: e as any};
            }
        }
    },
    /**
     * Get the raw data as a string
     *
     * # Arguments
     *
     * * `state` - The state to get the data from
     * * `data` - The data to get
     *
     * # Returns
     *
     * The raw data as a string
     */
    async cryptDataGetRawDataAsString(data: CryptData): Promise<Result<string, string>> {
        try {
            return {status: "ok", data: await TAURI_INVOKE("crypt_data_get_raw_data_as_string", {data})};
        }
        catch (e) {
            if (e instanceof Error) {
                throw e;
            }
            else {
                return {status: "error", error: e as any};
            }
        }
    },
    /**
     * Get the raw data
     *
     * # Arguments
     *
     * * `state` - The state to get the data from
     * * `data` - The data to get
     *
     * # Returns
     *
     * The raw data
     */
    async cryptDataGetRawData(data: CryptData): Promise<Result<number[], string>> {
        try {
            return {status: "ok", data: await TAURI_INVOKE("crypt_data_get_raw_data", {data})};
        }
        catch (e) {
            if (e instanceof Error) {
                throw e;
            }
            else {
                return {status: "error", error: e as any};
            }
        }
    },
    /**
     * Create a new CryptData struct using a fully qualified string
     *
     * # Arguments
     *
     * * `data` - The fully qualified string
     *
     * # Returns
     *
     * The CryptData struct
     *
     * # Example
     *
     * ```typescript
     * const data = "example string";
     * const qualified_data = StateMarker.asSecret(data);
     *
     * const crypt_data = await invoke("make_crypt_data_from_qualified_string", {data: qualified_data});
     * ```
     */
    async makeCryptDataFromQualifiedString(data: string): Promise<Result<CryptData, string>> {
        try {
            return {status: "ok", data: await TAURI_INVOKE("make_crypt_data_from_qualified_string", {data})};
        }
        catch (e) {
            if (e instanceof Error) {
                throw e;
            }
            else {
                return {status: "error", error: e as any};
            }
        }
    },
};

/** user-defined events **/


/** user-defined constants **/

export const STATE_FILE = "state.json" as const;

/** user-defined types **/

export type AppStateInnerKeys = "debounced_saver" | "password" | "providers" | "settings"
export type AppStateInnerResult =
/**
 * The password to access the secure storage
 */
    {
        password: CryptData
    } |
    /**
     * The list of providers
     */
    {
        providers: ProviderData[]
    } |
    /**
     * The settings of the application
     */
    {
        settings: Settings
    }
/**
 * Represent some data that have been managed cryptographically
 */
export type CryptData = {
    /**
     * The cryptographically modified data
     */
    data: number[];
    /**
     * The raw data, never stored on disk (this field is never serialized)
     */
    raw_data: number[] | null;
    /**
     * The working mode of the data
     */
    mode: number;
    /**
     * The salt applied when deriving the encryption key
     */
    salt: number[] | null
}
export type DefaultPageGeneralGroup =
/**
 * The dashboard page
 */
    "dashboard" |
    /**
     * The all my drives page
     */
    "all_my_drives" |
    /**
     * The settings page
     */
    "settings"
/**
 * The default page groups
 */
export type DefaultPageGroups =
/**
 * The general default page
 */
    {
        general: DefaultPageGeneralGroup
    } |
    /**
     * The provider default page
     */
    {
        providers: ProviderPage
    }
/**
 * The encryption settings
 */
export type EncryptionSettings = {
    /**
     * Whether to use advanced encryption.
     * Advanced encryption is the default option based on XChaCha20-Poly1305.
     * Data:
     * - key: 256 bits (32 bytes)
     * - nonce: 192 bits (24 bytes)
     * - tag: 128 bits (16 bytes)
     * Notes:
     * - Implemented in TLS
     * - Generally considered "more" secure than AES-GCM due to the longer nonce
     * - Not a NIST standard
     * - Very low probability of nonce reuse
     */
    advanced_encryption: boolean;
    /**
     * Whether to use military grade encryption.
     * Military grade encryption is based on AES-256-GCM (SIV mode, https://en.wikipedia.org/wiki/AES-GCM-SIV).
     * Data:
     * - key: 256 bits (32 bytes)
     * - nonce: 96 bits (12 bytes)
     * - tag: 128 bits (16 bytes)
     * Notes:
     * - NIST accepted security standard
     * - Used by the US government to protect classified information
     * - Notably shorter nonce than XChaCha20-Poly1305
     * - Higher probability of nonce reuse
     */
    military_grade_encryption: boolean;
    /**
     * Whether to encrypt the state file.
     */
    encrypt_state: boolean;
    /**
     * Whether to compress the state file.
     */
    compress_state: boolean
}
/**
 * The general behaviour settings
 */
export type GeneralBehaviour = {
    /**
     * The default page
     */
    default_page: DefaultPageGroups;
    /**
     * Whether to open files using the native application (if possible)
     *
     * This option requires 2 preconditions:
     * - a native application for the file type must be installed (such as word for .docx files)
     * - the provider must allow the file to be downloaded (example, onedrive for business may
     * not allow this)
     * - this optionally can install the ONLYOFFICE desktop editors
     * https://www.onlyoffice.com/download-desktop.aspx
     */
    default_to_native_app: boolean;
    /**
     * Whether to default to the web editor if the provider supports it
     *
     * This option requires the provider to support a web editor, if the provider does not support
     * a web editor, this option will be ignored
     */
    default_to_web_editor: boolean;
    /**
     * Whether to compress files before uploading, this is a per-provider setting.
     * Note that providers with editor and collaborative capabilities will be unable to read and
     * use your files.
     */
    compress_files: Partial<{ [key in StorageProvider]: boolean }>
}
/**
 * The data of a storage provider
 */
export type ProviderData = {
    /**
     * The access token
     */
    access_token: CryptData;
    /**
     * The refresh token
     */
    refresh_token: CryptData;
    /**
     * The expiry date of the token (utc unix timestamp)
     */
    expiry: bigint;
    /**
     * The owner of the token (email)
     */
    owner: string;
    /**
     * The provider of the token
     */
    provider: StorageProvider
}
/**
 * A provider page
 */
export type ProviderPage = {
    /**
     * The storage provider
     */
    provider: StorageProvider;
    /**
     * The owner of the provider
     */
    owner: string
}
export type Security = {
    /**
     * The password hint, this is used to help the user remember their password.
     * This will be shown on every login screen.
     */
    password_hint: string | null;
    /**
     * The encryption settings
     */
    encryption: EncryptionSettings;
    /**
     * The two-factor authentication settings
     */
    two_factor_authentication: TwoFactorAuthentication;
    /**
     * The state file signature, this is used to verify the integrity of the state file.
     */
    signature: CryptData
}
/**
 * The settings of the application
 */
export type Settings = {
    /**
     * The theme settings
     */
    theme: ThemeSettings;
    /**
     * The general behaviour settings
     */
    general_behaviour: GeneralBehaviour;
    /**
     * The security settings
     */
    security: Security
}
export type SettingsResult =
/**
 * The theme settings
 */
    {
        theme: ThemeSettings
    } |
    /**
     * The general behaviour settings
     */
    {
        general_behaviour: GeneralBehaviour
    } |
    /**
     * The security settings
     */
    {
        security: Security
    }
/**
 * The available storage providers
 */
export type StorageProvider = "unrecognized" | "google" | "dropbox" | "onedrive" | "terabox"
export type Theme = "light" | "dark" | "system"
/**
 * The theme settings
 */
export type ThemeSettings = {
    /**
     * The application font size in pixels
     */
    font_size: number;
    /**
     * The application theme
     */
    theme: Theme
}
/**
 * The two factor authentication settings
 */
export type TwoFactorAuthentication = {
    /**
     * Whether to use two factor authentication
     */
    enabled: boolean;
    /**
     * The two factor authentication secret
     */
    secret: CryptData | null
}

/** tauri-specta globals **/

import { invoke as TAURI_INVOKE } from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
    listen: (
        cb: TAURI_API_EVENT.EventCallback<T>,
    ) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
    once: (
        cb: TAURI_API_EVENT.EventCallback<T>,
    ) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
    emit: null extends T
          ? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
          : (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
    | {
          status: "ok";
          data: T
      }
    | {
          status: "error";
          error: E
      };

function __makeEvents__<T extends Record<string, any>>(
    mappings: Record<keyof T, string>,
) {
    return new Proxy(
        {} as unknown as {
            [K in keyof T]: __EventObj__<T[K]> & {
            (handle: __WebviewWindow__): __EventObj__<T[K]>;
        };
        },
        {
            get: (_, event) => {
                const name = mappings[event as keyof T];

                return new Proxy((
                    () => {}
                ) as any, {
                    apply: (_, __, [ window ]: [ __WebviewWindow__ ]) => (
                        {
                            listen: (arg: any) => window.listen(name, arg),
                            once:   (arg: any) => window.once(name, arg),
                            emit:   (arg: any) => window.emit(name, arg),
                        }
                    ),
                    get:   (_, command: keyof __EventObj__<any>) => {
                        switch (command) {
                            case "listen":
                                return (arg: any) => TAURI_API_EVENT.listen(name, arg);
                            case "once":
                                return (arg: any) => TAURI_API_EVENT.once(name, arg);
                            case "emit":
                                return (arg: any) => TAURI_API_EVENT.emit(name, arg);
                        }
                    },
                });
            },
        },
    );
}
