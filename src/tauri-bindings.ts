// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file
// manually.

/** user-defined commands **/


export const commands = {
    async startServer(): Promise<Result<number, string>> {
        try {
            return {status: "ok", data: await TAURI_INVOKE("start_server")};
        }
        catch (e) {
            if (e instanceof Error) {
                throw e;
            }
            else {
                return {status: "error", error: e as any};
            }
        }
    },
    /**
     * Sets the password for the application secure storage.
     *
     * # Arguments
     *
     * * `password` - The password to set.
     *
     * # Returns
     *
     * Nothing.
     */
    async initState(password: string): Promise<Result<null, string>> {
        try {
            return {status: "ok", data: await TAURI_INVOKE("init_state", {password})};
        }
        catch (e) {
            if (e instanceof Error) {
                throw e;
            }
            else {
                return {status: "error", error: e as any};
            }
        }
    },
    /**
     * Gets data from the state.
     *
     * # Arguments
     *
     * * `state` - The state to get the data from.
     * * `key` - The key to get the data from.
     *
     * # Returns
     *
     * The data as a JSON value.
     */
    async getFromState(key: AppStateDeepKeys): Promise<Result<AppStateDeepResult, string>> {
        try {
            return {status: "ok", data: await TAURI_INVOKE("get_from_state", {key})};
        }
        catch (e) {
            if (e instanceof Error) {
                throw e;
            }
            else {
                return {status: "error", error: e as any};
            }
        }
    },
    /**
     * Removes data from the state.
     *
     * # Arguments
     *
     * * `state` - The state to remove the data from.
     * * `key` - The key to remove the data from.
     *
     * # Returns
     *
     * Nothing.
     */
    async removeFromState(key: AppStateDeepKeys): Promise<Result<null, string>> {
        try {
            return {status: "ok", data: await TAURI_INVOKE("remove_from_state", {key})};
        }
        catch (e) {
            if (e instanceof Error) {
                throw e;
            }
            else {
                return {status: "error", error: e as any};
            }
        }
    },
    /**
     * Inserts data in the state.
     *
     * # Arguments
     *
     * * `state` - The state to insert the data in.
     * * `value` - The data to insert.
     *
     * # Returns
     *
     * Nothing.
     */
    async insertInState(value: AppStateDeepResult): Promise<Result<null, string>> {
        try {
            return {status: "ok", data: await TAURI_INVOKE("insert_in_state", {value})};
        }
        catch (e) {
            if (e instanceof Error) {
                throw e;
            }
            else {
                return {status: "error", error: e as any};
            }
        }
    },
    /**
     * Checks if the user is authenticated.
     *
     * # Returns
     *
     * True if the user is authenticated, false otherwise.
     */
    async isAuthenticated(): Promise<boolean> {
        return await TAURI_INVOKE("is_authenticated");
    },
    /**
     * Gets the password for the application secure storage if already loaded in memory.
     *
     * # Why
     *
     * This function is useful when the frontend needs to initialize the State class or some other
     * singleton but the password was not provided at application startup.
     * This is most commonly a development issue (commonly derived from hot-reloading) but implementing
     * a safe reboot of singleton in case the password is missing can be useful to improve the user
     * experience.
     *
     * **Note**: This function DOES NOT expose the password to other applications or the networks.
     *
     * # Returns
     *
     * The password.
     */
    async getPassword(): Promise<Result<string, string>> {
        try {
            return {status: "ok", data: await TAURI_INVOKE("get_password")};
        }
        catch (e) {
            if (e instanceof Error) {
                throw e;
            }
            else {
                return {status: "error", error: e as any};
            }
        }
    },
    /**
     * Gets the settings of the application.
     *
     * # Arguments
     *
     * * `state` - The state to get the settings from.
     *
     * # Returns
     *
     * The settings of the application.
     */
    async loadSettings(): Promise<Result<Settings, string>> {
        try {
            return {status: "ok", data: await TAURI_INVOKE("load_settings")};
        }
        catch (e) {
            if (e instanceof Error) {
                throw e;
            }
            else {
                return {status: "error", error: e as any};
            }
        }
    },
    /**
     * Updates the settings of the application.
     *
     * # Arguments
     *
     * * `state` - The state to update the settings in.
     * * `value` - The settings to update.
     *
     * # Returns
     *
     * Nothing.
     */
    async updateSettings(value: SettingsResult): Promise<Result<null, string>> {
        try {
            return {status: "ok", data: await TAURI_INVOKE("update_settings", {value})};
        }
        catch (e) {
            if (e instanceof Error) {
                throw e;
            }
            else {
                return {status: "error", error: e as any};
            }
        }
    },
    /**
     * Check that the password is correct
     *
     * # Arguments
     *
     * - `state` - The application state
     * - `password` - The password to check
     *
     * # Returns
     *
     * Returns `Ok(())` if the password is correct, otherwise returns `Err("Invalid password")`
     */
    async checkPassword(password: string): Promise<Result<null, string>> {
        try {
            return {status: "ok", data: await TAURI_INVOKE("check_password", {password})};
        }
        catch (e) {
            if (e instanceof Error) {
                throw e;
            }
            else {
                return {status: "error", error: e as any};
            }
        }
    },
    /**
     * Update the password
     *
     * Note that this triggers the update of all encrypted data too as the password is used to encrypt them.
     *
     * # Arguments
     *
     * - `state` - The application state
     * - `current_password` - The current password
     * - `new_password` - The new password
     * - `ev` - The event channel
     *
     * # Returns
     *
     * Returns `Ok(())` if the password was updated successfully, otherwise returns `Err(String)`
     */
    async updatePassword(
        currentPassword: string,
        newPassword: string,
        ev: TAURI_CHANNEL<PasswordUpdateEvent>,
    ): Promise<Result<null, string>> {
        try {
            return {status: "ok", data: await TAURI_INVOKE("update_password", {currentPassword, newPassword, ev})};
        }
        catch (e) {
            if (e instanceof Error) {
                throw e;
            }
            else {
                return {status: "error", error: e as any};
            }
        }
    },
    /**
     * Get the raw data as a string
     *
     * # Arguments
     *
     * * `state` - The state to get the data from
     * * `data` - The data to get
     *
     * # Returns
     *
     * The raw data as a string
     */
    async cryptDataGetRawDataAsString(data: CryptData): Promise<Result<string, string>> {
        try {
            return {status: "ok", data: await TAURI_INVOKE("crypt_data_get_raw_data_as_string", {data})};
        }
        catch (e) {
            if (e instanceof Error) {
                throw e;
            }
            else {
                return {status: "error", error: e as any};
            }
        }
    },
    /**
     * Get the raw data
     *
     * # Arguments
     *
     * * `state` - The state to get the data from
     * * `data` - The data to get
     *
     * # Returns
     *
     * The raw data
     */
    async cryptDataGetRawData(data: CryptData): Promise<Result<number[], string>> {
        try {
            return {status: "ok", data: await TAURI_INVOKE("crypt_data_get_raw_data", {data})};
        }
        catch (e) {
            if (e instanceof Error) {
                throw e;
            }
            else {
                return {status: "error", error: e as any};
            }
        }
    },
    /**
     * Create a new CryptData struct using a fully qualified string
     *
     * # Arguments
     *
     * * `data` - The fully qualified string
     *
     * # Returns
     *
     * The CryptData struct
     *
     * # Example
     *
     * ```typescript
     * const data = "example string";
     * const qualified_data = StateMarker.asSecret(data);
     *
     * const crypt_data = await invoke("make_crypt_data_from_qualified_string", {data: qualified_data});
     * ```
     */
    async makeCryptDataFromQualifiedString(data: string): Promise<Result<CryptData, string>> {
        try {
            return {status: "ok", data: await TAURI_INVOKE("make_crypt_data_from_qualified_string", {data})};
        }
        catch (e) {
            if (e instanceof Error) {
                throw e;
            }
            else {
                return {status: "error", error: e as any};
            }
        }
    }
}

/** user-defined events **/



/** user-defined constants **/

export const STATE_FILE = "state.json" as const;

/** user-defined types **/

export type AppStateDeepKeys = "debounced_saver" | "password" | "providers" | "settings"
export type AppStateDeepResult = 
/**
 * The password to access the secure storage
 */
    {
        password: CryptData
    } |
    /**
     * The list of providers
     */
    {
        providers: ProviderData[]
    } |
    /**
     * The settings of the application
     */
    {
        settings: Settings
    }
/**
 * Represent some data that have been managed cryptographically
 */
export type CryptData = {
    /**
     * The cryptographically modified data
     */
    data: number[];
    /**
     * The raw data, never stored on disk (this field is never serialized)
     */
    raw_data: number[] | null;
    /**
     * The working mode of the data
     */
    mode: number;
    /**
     * The salt applied when deriving the encryption key
     */
    salt: number[] | null;
    /**
     * The list of related keys in the parent struct, this is used to understand which values are
     * required to (re-)compute the hash
     */
    related_keys: string[]
}
export type DefaultPageGeneralGroup = 
/**
 * The dashboard page
 */
    "dashboard" |
    /**
     * The all my drives page
     */
    "all_my_drives" |
    /**
     * The settings page
     */
    "settings"
/**
 * The default page groups
 */
export type DefaultPageGroups = 
/**
 * The general default page
 */
    {
        general: DefaultPageGeneralGroup
    } |
    /**
     * The provider default page
     */
    {
        providers: ProviderPage
    }
/**
 * The encryption settings
 */
export type EncryptionSettings = {
    /**
     * Whether to encrypt the state file.
     */
    encrypt_state: boolean;
    /**
     * Whether to compress the state file.
     */
    compress_state: boolean
}
/**
 * The general behaviour settings
 */
export type GeneralBehaviour = {
    /**
     * The default page
     */
    default_page: DefaultPageGroups;
    /**
     * Whether to open files using the native application (if possible)
     *
     * This option requires 2 preconditions:
     * - a native application for the file type must be installed (such as word for .docx files)
     * - the provider must allow the file to be downloaded (example, onedrive for business may
     * not allow this)
     * - this optionally can install the ONLYOFFICE desktop editors
     * https://www.onlyoffice.com/download-desktop.aspx
     */
    default_to_native_app: boolean;
    /**
     * Whether to default to the web editor if the provider supports it
     *
     * This option requires the provider to support a web editor, if the provider does not support
     * a web editor, this option will be ignored
     */
    default_to_web_editor: boolean;
    /**
     * Whether to compress files before uploading, this is a per-provider setting.
     * Note that providers with editor and collaborative capabilities will be unable to read and
     * use your files.
     */
    compress_files: Partial<{ [key in StorageProvider]: boolean }>
}
export type PasswordUpdateEvent =
    {
        event: "initialized";
        data: {
            steps: number
        }
    }
    | {
        event: "step_completed"
    }
    | {
        event: "completed"
    }
/**
 * The data of a storage provider
 */
export type ProviderData = {
    /**
     * The access token
     */
    access_token: CryptData;
    /**
     * The refresh token
     */
    refresh_token: CryptData;
    /**
     * The expiry date of the token (utc unix timestamp)
     */
    expiry: bigint;
    /**
     * The owner of the token (email)
     */
    owner: string;
    /**
     * The provider of the token
     */
    provider: StorageProvider
}
/**
 * A provider page
 */
export type ProviderPage = {
    /**
     * The storage provider
     */
    provider: StorageProvider;
    /**
     * The owner of the provider
     */
    owner: string
}
export type Security = {
    /**
     * The encryption settings
     */
    encryption: EncryptionSettings;
    /**
     * The two-factor authentication settings
     */
    two_factor_authentication: TwoFactorAuthentication;
    /**
     * The state file signature, this is used to verify the integrity of the state file.
     */
    signature: CryptData
}
/**
 * The settings of the application
 */
export type Settings = {
    /**
     * The theme settings
     */
    theme: ThemeSettings;
    /**
     * The general behaviour settings
     */
    general_behaviour: GeneralBehaviour;
    /**
     * The security settings
     */
    security: Security
}
export type SettingsResult = 
/**
 * The theme settings
 */
    {
        theme: ThemeSettings
    } |
    /**
     * The general behaviour settings
     */
    {
        general_behaviour: GeneralBehaviour
    } |
    /**
     * The security settings
     */
    {
        security: Security
    }
/**
 * The available storage providers
 */
export type StorageProvider = "unrecognized" | "google" | "dropbox" | "onedrive" | "terabox"
export type Theme = "light" | "dark" | "system"
/**
 * The theme settings
 */
export type ThemeSettings = {
    /**
     * The application font size in pixels
     */
    font_size: number;
    /**
     * The application theme
     */
    theme: Theme
}
/**
 * The two factor authentication settings
 */
export type TwoFactorAuthentication = {
    /**
     * Whether to use two factor authentication
     */
    enabled: boolean;
    /**
     * The two factor authentication secret
     */
    secret: CryptData | null
}

/** tauri-specta globals **/

import { Channel as TAURI_CHANNEL, invoke as TAURI_INVOKE } from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
    listen: (
        cb: TAURI_API_EVENT.EventCallback<T>,
    ) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
    once: (
        cb: TAURI_API_EVENT.EventCallback<T>,
    ) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
    emit: null extends T
          ? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
          : (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
    | {
          status: "ok";
          data: T
      }
    | {
          status: "error";
          error: E
      };

function __makeEvents__<T extends Record<string, any>>(
    mappings: Record<keyof T, string>,
) {
    return new Proxy(
        {} as unknown as {
            [K in keyof T]: __EventObj__<T[K]> & {
            (handle: __WebviewWindow__): __EventObj__<T[K]>;
        };
        },
        {
            get: (_, event) => {
                const name = mappings[event as keyof T];

                return new Proxy((
                    () => {}
                ) as any, {
                    apply: (_, __, [ window ]: [ __WebviewWindow__ ]) => (
                        {
                            listen: (arg: any) => window.listen(name, arg),
                            once:   (arg: any) => window.once(name, arg),
                            emit:   (arg: any) => window.emit(name, arg),
                        }
                    ),
                    get:   (_, command: keyof __EventObj__<any>) => {
                        switch (command) {
                            case "listen":
                                return (arg: any) => TAURI_API_EVENT.listen(name, arg);
                            case "once":
                                return (arg: any) => TAURI_API_EVENT.once(name, arg);
                            case "emit":
                                return (arg: any) => TAURI_API_EVENT.emit(name, arg);
                        }
                    },
                });
            },
        },
    );
}
